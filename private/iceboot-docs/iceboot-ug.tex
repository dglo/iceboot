\documentclass{article}
\usepackage{graphicx}
\usepackage{makeidx}

\makeindex

\newcommand{\cmd}[4]{
	\subsection{#1} \index{Commands!#1}
	\emph{#2} #1 \emph{#3} \\
	#4
}

\begin{document}

\title{Iceboot Users Guide}
\author{Arthur Jones \\ Lawrence Berkeley National Labs }
\maketitle
\thispagestyle{empty}

\eject

The work described here was created with help
of many people -- I'd like to point out just a few.

Thanks to Azriel Goldschmidt, who put up with the
buggy software and offered many helpful suggestions
and comments.

Thanks to Simon Patton, who put together the build environment
which helps keep the project on track and usable
by others.

Thanks to Thorsten Stezelberger, without whom
I would have been completely incapable of testing
any of the software described below.

Thanks to Chuck McParland, who pretty much
completely defined what the software should 
do -- definitely the hardest part of getting the
software to work.

Thanks to Gerald Przybylsky
for sharing his workspace the last few months
and putting up with -- even answering -- so 
many na\" \i ve hardware questions.

\thispagestyle{empty}

\eject

\tableofcontents

\eject

\section{Introduction}

This document describes
the DOM mainboard software environment to
users and programmers.

\section{Booting the Hardware}

After power on reset, the epxa ARM processor
begins the boot process.  If the Boot from
Flash \index{Boot from Flash} pin is active,
the Excalibur starts execution from the start
of the EBI0 address space -- hardwired to be
at address 0x40000000.  If the Boot from Flash
pin is inactive, the CPU will take boot code
and an fpga design file from a local programmable
ROM device.  This document describes the boot
from flash mode, the boot from serial mode (ConfigBoot) will
be described elsewhere.
The CPU must initialize
many pieces of hardware, so that the software
environment can be setup. All of the hardware described below
is configurable, a description of the configuration file used
is found in section \ref{configfile}
on page \pageref{configfile}.  The following
sections will step through the boot process.

	\subsection{Initialize Hardware}

First in line to be programmed are the EPXA PLLS.
There are two of them:  PLL1 \index{EPXA!PLL1} and PLL2\index{EPXA!PLL2},
PLL1 drives the AHB1 \index{EPXA!AHB1} after a divide by two (AHB1 is
one half the frequency of PLL1) and PLL2 drives the AHB2\index{EPXA!AHB2} 
clock after
a divide by two.  The AHB1 clock is the main CPU clock and the
AHB2 clock is used for the SDRAM clock.

After the PLLs are setup, the iocontrol registers are
configured, this lets us configure slew rates and other
parameters for output pins on the epxa.

Next in line is initializing the UART\index{UART}.  Here we setup
the Excalibur chip to do serial communications.  The
chip is reset and the baud rate and other programmable
options are setup.

After the UART is setup, the EBI\index{EBI} bus parameters
are setup.  Generic options which affect all the
EBI chip select devices are setup here, like
clock rate, and also chip select specific options
are setup here as well.

The SDRAM controller\index{SDRAM!controller} is configured next.  The
parameters for the SDRAM chip on the board are
programmed into the controller and the controller
is initialized.

Many of the devices that were configured can be
accessed through memory locations on the Excalibur
chip.  These physical memory locations are setup 
next.

\index{SDRAM!booting from} At this point in 
the bootup process, we have all
the one-time hardware initializations done.  We
now want to load our boot code from flash to the
SDRAM that has just been configured.  After copying
the boot code to the start of SDRAM, it is verified
against the flash memory.  If the verify fails, the
booter will print out the expected value (flash value), 
the actual value read from SDRAM and the address of
the error.

The final step in the low-level boot code is to
jump to the code that contains the boot prompt,
Iceboot.

\section{Iceboot Command Line Interface}
	\subsection{Overview}

Once the hardware is initialized, we want to run
the command line boot environment, this will allow us 
to read and write memory locations, store and load
images from the flash chips, execute programs stored
in memory and other low-level functions.  The booter
provides a prompt which allows the user to 
type in commands one line at a time.  If the user
has access to a vt100 terminal, the Up-arrow and
Down-Arrow keys will cycle through the last few
commands run, the left and right arrows allows
the user to position the cursor and the backspace
key allows the user to destructively delete the
previous character on a line.  On most any terminal 
the Control-F and Control-B key sequences allow 
the user to go forward and backward one word.
Iceboot implements an extremely limited subset
of the Forth programming language.  Forth is a
stack oriented language which has been said to
optimize interpreter development time.  The following
sections describe the forth words that are implemented
by Iceboot.

	\subsection{Commands}	

List of commands \ldots

\cmd{!, w!, c!}{value address}{}{Put value into address, 32bit, 16bit or
  8bit move.}
\cmd{*}{a b}{result}{a * b}
\cmd{+}{a b}{result}{a + b}
\cmd{-}{a b}{result}{a - b}
\cmd{.}{}{}{Print top of stack}
\cmd{.s}{}{}{Print entire stack}
\cmd{/}{a b}{result}{a / b}
\cmd{:}{}{}{Start function definition.}
\cmd{ < ) }{a b}{result}{a < b}
\cmd{=}{a b}{result}{a = b}
\cmd{ > }{a b}{result}{a > b}
\cmd{?DO}{end start}{}{Execute code from end (exclusive) to start (inclusive)}
\cmd{@, w@, c@}{address}{value}{Get a 32bit word, 16bit word or 8 bit word
  from \emph{address}}
\cmd{$\backslash$$\backslash$}{}{}{Comment character, all characters
to end of line are ignored by interpreter}
\cmd{allocate}{nbytes}{address}{Allocate nbytes on the heap address is put
  on the stack.}
\cmd{analogMuxInput}{channel}{}{Select analog mux input channel}
\cmd{and}{a b}{result}{a and b}
\cmd{base}{}{address}{Address of number base (10=decimal, 16=hex, ...)}
\cmd{boardID}{}{address length}{get address and length of boardID string}
\cmd{compress}{srcAddress srcLength}{destAddress destLength}{
 Compress the data at srcAddress with length srcLength and return
 the destAddress and destLength of the compressed data
}
\cmd{constant}{a}{name}{Set name to constant value a}
\cmd{create}{nameAddress nameLength dataAddress dataLength}{}{
	Create a file on the flash filesystem with name at
address nameAddress of length nameLength using data at dataAddress
with length dataLength.
}
\cmd{crlf}{}{}{Print carraige return line feed characters}
\cmd{disableCurrents}{}{result}{address of flag to set to disable printing of currents on the top of the screen}
\cmd{drop}{}{}{Drop the top stack element}
\cmd{dup}{a}{a a}{Duplicate the top stack element}
\cmd{exec}{execAddress execLength}{}{Execute the program at execAddress with
length execLength}
\cmd{false}{}{false}{return false (0)}
\cmd{find}{nameAddress nameLength}{fileAddress fileLength status}{
	find the file with name at nameAddress of length nameLength
and return it's address and length to the stack if status=1, if status=0
then do nothing.
}
\cmd{fpga}{sbiAddress sbiLength}{status}{Program the fpga with the
sbi file at sbiAddress with length sbiLength, return status = 0 if
all is ok, otherwise return error code.}
\cmd{free}{address}{}{Free allocated data at address.}
\cmd{gunzip}{dataAddress dataLength}{destAddress destLength}{
	gunzip a gzip file at dataAddress of length dataLength and
put the resulting data in destAddress with length destLength.
}
\cmd{i}{}{value of counter}{returns value of index variable in a ?DO loop.}
\cmd{iceboot}{}{cmds\ldots}{run iceboot cmds\ldots}
\cmd{if cmds endif}{cond}{}{execute commands if cond is non-zero}
\cmd{init}{}{}{initialize flash filesystem}
\cmd{interpret}{srcAddress srcLength}{}{Interpret data at
address srcAddress with length srcLength}
\cmd{lock}{nameAddress nameLength}{}{lock flash file with name at nameAddress
with length nameLength }
\cmd{ls}{}{}{print listing of flash filesystem directory}
\cmd{lshift}{value shift}{result}{result = value shifted left shift}
\cmd{not}{a}{result}{ result = !a}
\cmd{od}{count address}{}{print count hex words at address}
\cmd{prtCookedCurrents}{}{}{show cooked currents (efficiency corrected)}
\cmd{prtPLL}{n}{}{print pll information for pll n (1 or 2)}
\cmd{prtRawCurrents}{}{}{print raw currents (not efficiency corrected)}
\cmd{prtTemp}{code}{}{decode temperature and print it}
\cmd{rawCurrents}{}{address}{return address of a flag to determine
whether or not to print raw or cooked currents to the top of the screen.}
\cmd{readADC}{channel}{value}{read ADC at channel }
\cmd{readDAC}{channel}{value}{read DAC at channel }
\cmd{readTemp}{}{code}{return coded temperature value}
\cmd{reboot}{}{}{reboot the DOM}
\cmd{rm}{nameAddress nameLength}{}{remove the file with name at nameAddress
and length of nameLength}
\cmd{rshift}{value shift}{result}{ result = value right shifted shift}
\cmd{s`` words''}{}{wordsAddress wordsLength}{return string at wordsAddress
with length wordsLength}
\cmd{swap}{}{}{ swap the two top words of the stack}
\cmd{true}{}{result}{return a true result (-1)}
\cmd{type}{stringAddress stringLength}{}{print string at stringAddress
with length stringLength}
\cmd{unlock}{nameAddress nameLength}{}{unlock flash data with file name at
nameAddress with length nameLength}
\cmd{usleep}{us}{}{sleep for us microseconds}
\cmd{writeDAC}{channel value}{}{write value to DAC channel}
\cmd{xor}{a b}{result}{result = a xor b}
\cmd{ymodem1k}{}{dataAddress dataLength}{
	Download a file over the terminal return the address
and length of the data returned.
}

\section{Coding and Building the software}
	\subsection{Overview}
	
Iceboot is a combination of a few different projects
that are checked into the icecube CVS repository.  The
following sections describe the different projects.

	\subsection{hal}

The hal project defines and implements the hardware access layer.  
It is used to 
abstract hardware access to facilitate simulation
without real hardware.

	\subsection{dom-loader}

The dom-loader project contains the hardware configuration file that 
is used to configure the hardware on bootup.  This allows us to 
                         use epxa1 and epxa4 chips and
                          deal with different setting of the
                          dom-mainboard and the epxa eval boards
			\label{configfile}.  The config file is
parsed to generate the low-level assembler code that configures
the hardware.

This project also builds the boot image and contains the
low-level code necessary to get read/write access to stdin
and stdout over the serial port, or, eventually, the communications
channel.
			
	\subsection{iceboot}

The    Iceboot project contains the C source for
the forth interpreter.

	\subsection{stf}

Once hardware is working, a pass/fail high-level test
is often required.  The stf project provides the infrastructure
for creating, running, reporting and archiving this test
information.

\printindex

\end{document}








